/*
Package http GENERATED BY gengo:runtimedoc
DON'T EDIT THIS FILE
*/
package http

func (v *Do) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Method":
			return []string{
				"http method",
			}, true
		case "Url":
			return []string{
				"http request url",
			}, true
		case "Header":
			return []string{
				"http headers",
			}, true
		case "Query":
			return []string{
				"http query",
			}, true
		case "RequestBody":
			return []string{
				"http request body",
			}, true
		case "With":
			return []string{
				"options",
			}, true
		case "Response":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"http request",
	}, true
}

func (v *DoOption) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "ExposeHeaders":
			return []string{
				"header keys for result",
			}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Fetch) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Url":
			return []string{
				"http request url",
			}, true
		case "HitBy":
			return []string{
				"hit by response header",
			}, true
		case "File":
			return []string{
				"fetched file",
			}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"http resource to local cache",
	}, true
}

func (v *Response) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Status":
			return []string{
				"status code",
			}, true
		case "Header":
			return []string{
				"response header, only pick headers requests by `with.header`",
			}, true
		case "Data":
			return []string{
				"auto unmarshal based on content-type",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

// nolint:deadcode,unused
func runtimeDoc(v any, prefix string, names ...string) ([]string, bool) {
	if c, ok := v.(interface {
		RuntimeDoc(names ...string) ([]string, bool)
	}); ok {
		doc, ok := c.RuntimeDoc(names...)
		if ok {
			if prefix != "" && len(doc) > 0 {
				doc[0] = prefix + doc[0]
				return doc, true
			}

			return doc, true
		}
	}
	return nil, false
}
