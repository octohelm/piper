/*
Package container GENERATED BY gengo:runtimedoc
DON'T EDIT THIS FILE
*/
package container

func (v *Auth) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Username":
			return []string{}, true
		case "Secret":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Build) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Steps":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Group, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"docker build step",
	}, true
}

func (v *CacheDir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "ID":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Config) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Auths":
			return []string{}, true
		}
		if doc, ok := runtimeDoc(&v.SetupTask, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Container) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Rootfs":
			return []string{}, true
		case "Platform":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Copy) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Contents":
			return []string{}, true
		case "Source":
			return []string{}, true
		case "Include":
			return []string{}, true
		case "Exclude":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Diff) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Upper":
			return []string{}, true
		case "Lower":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Dir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Dump) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "OutDir":
			return []string{}, true
		case "With":
			return []string{}, true
		case "Dir":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DumpOption) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Empty":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Exec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Args":
			return []string{}, true
		case "Mounts":
			return []string{}, true
		case "Env":
			return []string{}, true
		case "Workdir":
			return []string{}, true
		case "Entrypoint":
			return []string{}, true
		case "User":
			return []string{}, true
		case "Always":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Export) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Annotations":
			return []string{
				"oci annotations",
			}, true
		case "OutFile":
			return []string{}, true
		case "File":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Fs) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		}

		return nil, false
	}
	return []string{}, true
}

func (v *HTTPFetch) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Source":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *ImageConfig) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "WorkingDir":
			return []string{}, true
		case "Env":
			return []string{}, true
		case "Labels":
			return []string{}, true
		case "Entrypoint":
			return []string{}, true
		case "Cmd":
			return []string{}, true
		case "User":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (*LazyDoFn) RuntimeDoc(names ...string) ([]string, bool) {
	return []string{}, true
}

func (v *Merge) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Inputs":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Mkdir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Permissions":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Mount) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		}
		if doc, ok := runtimeDoc(&v.Mounter, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *MountCacheDir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Contents":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *MountFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Contents":
			return []string{}, true
		case "Permissions":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *MountFs) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Contents":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Source":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *MountSecret) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Contents":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *MountTemp) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Dest":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Pull) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Source":
			return []string{
				"image from",
			}, true
		case "Platform":
			return []string{
				"image platform",
			}, true
		case "Auth":
			return []string{
				"registry auth",
			}, true
		case "Output":
			return []string{
				"image",
			}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"image from",
	}, true
}

func (v *Push) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Dest":
			return []string{
				"image tag",
			}, true
		case "Images":
			return []string{
				"images for push",
				"[Platform]: _",
			}, true
		case "Annotations":
			return []string{
				"annotations",
			}, true
		case "Auth":
			return []string{
				"registry auth",
			}, true
		case "Result":
			return []string{
				"image pushed result",
			}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"image to registry",
	}, true
}

func (v *ReadFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Contents":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *RegistryAuth) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Address":
			return []string{}, true
		case "Username":
			return []string{}, true
		case "Password":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Rm) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *RootfsDo) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Steps":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Group, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"FsDo docker build but with rootfs",
	}, true
}

func (v *RootfsDoStepInterface) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Output":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Run) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Mounts":
			return []string{}, true
		case "Env":
			return []string{}, true
		case "Workdir":
			return []string{}, true
		case "User":
			return []string{}, true
		case "Always":
			return []string{}, true
		case "Shell":
			return []string{}, true
		case "Run":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Set) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Config":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Source) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Cwd":
			return []string{
				"working dir",
			}, true
		case "Path":
			return []string{}, true
		case "Include":
			return []string{}, true
		case "Exclude":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *SourceFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "File":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *StepInterface) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Output":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Stretch) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Platform":
			return []string{
				"image platform",
			}, true
		case "Output":
			return []string{
				"image",
			}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"image from stretch",
	}, true
}

func (v *Sub) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{
				"source fs",
			}, true
		case "Source":
			return []string{}, true
		case "Include":
			return []string{}, true
		case "Exclude":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *WriteFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Permissions":
			return []string{}, true
		case "Contents":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.Task, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

// nolint:deadcode,unused
func runtimeDoc(v any, prefix string, names ...string) ([]string, bool) {
	if c, ok := v.(interface {
		RuntimeDoc(names ...string) ([]string, bool)
	}); ok {
		doc, ok := c.RuntimeDoc(names...)
		if ok {
			if prefix != "" && len(doc) > 0 {
				doc[0] = prefix + doc[0]
				return doc, true
			}

			return doc, true
		}
	}
	return nil, false
}
