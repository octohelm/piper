/*
Package container GENERATED BY gengo:runtimedoc 
DON'T EDIT THIS FILE
*/
package container

// nolint:deadcode,unused
func runtimeDoc(v any, names ...string) ([]string, bool) {
	if c, ok := v.(interface {
		RuntimeDoc(names ...string) ([]string, bool)
	}); ok {
		return c.RuntimeDoc(names...)
	}
	return nil, false
}

func (v Auth) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Username":
			return []string{}, true
		case "Secret":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Build) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Group":
			return []string{}, true
		case "Steps":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Group, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Build docker build step",
	}, true
}

func (v CacheDir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "ID":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Config) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "SetupTask":
			return []string{}, true
		case "Auths":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.SetupTask, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Container) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Rootfs":
			return []string{}, true
		case "Platform":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Copy) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Contents":
			return []string{}, true
		case "Source":
			return []string{}, true
		case "Include":
			return []string{}, true
		case "Exclude":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Diff) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Upper":
			return []string{}, true
		case "Lower":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Dir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Dump) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "OutDir":
			return []string{}, true
		case "With":
			return []string{}, true
		case "Dir":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v DumpOption) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Empty":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Exec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Args":
			return []string{}, true
		case "Mounts":
			return []string{}, true
		case "Env":
			return []string{}, true
		case "Workdir":
			return []string{}, true
		case "Entrypoint":
			return []string{}, true
		case "User":
			return []string{}, true
		case "Always":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Export) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Annotations":
			return []string{
				"oci annotations",
			}, true
		case "OutFile":
			return []string{}, true
		case "File":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Fs) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {

		}

		return nil, false
	}
	return []string{}, true
}

func (v HTTPFetch) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Source":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v ImageConfig) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "WorkingDir":
			return []string{}, true
		case "Env":
			return []string{}, true
		case "Labels":
			return []string{}, true
		case "Entrypoint":
			return []string{}, true
		case "Cmd":
			return []string{}, true
		case "User":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (LazyDoFn) RuntimeDoc(names ...string) ([]string, bool) {
	return []string{}, true
}
func (v Merge) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Inputs":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Mkdir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Permissions":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Mount) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Mounter":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Mounter, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v MountCacheDir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Contents":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v MountFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Contents":
			return []string{}, true
		case "Permissions":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v MountFs) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Contents":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Source":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v MountSecret) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Contents":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v MountTemp) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Dest":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Pull) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Source":
			return []string{
				"image from",
			}, true
		case "Platform":
			return []string{
				"image platform",
			}, true
		case "Auth":
			return []string{
				"registry auth",
			}, true
		case "Output":
			return []string{
				"image",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Pull",
		"image from",
	}, true
}

func (v Push) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Dest":
			return []string{
				"image tag",
			}, true
		case "Images":
			return []string{
				"images for push",
				"[Platform]: _",
			}, true
		case "Auth":
			return []string{
				"registry auth",
			}, true
		case "Result":
			return []string{
				"image pushed result",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Push image to registry",
	}, true
}

func (v ReadFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Contents":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Rm) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v RootfsDo) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Group":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Steps":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Group, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"FsDo docker build but with rootfs",
	}, true
}

func (v RootfsDoStepInterface) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Output":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Run) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Mounts":
			return []string{}, true
		case "Env":
			return []string{}, true
		case "Workdir":
			return []string{}, true
		case "User":
			return []string{}, true
		case "Always":
			return []string{}, true
		case "Shell":
			return []string{}, true
		case "Run":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Set) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Config":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v Source) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Cwd":
			return []string{
				"working dir",
			}, true
		case "Path":
			return []string{}, true
		case "Include":
			return []string{}, true
		case "Exclude":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v SourceFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "File":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v StepInterface) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Input":
			return []string{}, true
		case "Output":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Stretch) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Platform":
			return []string{
				"image platform",
			}, true
		case "Output":
			return []string{
				"image",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Stretch",
		"image from stretch",
	}, true
}

func (v Sub) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{
				"source fs",
			}, true
		case "Source":
			return []string{}, true
		case "Include":
			return []string{}, true
		case "Exclude":
			return []string{}, true
		case "Dest":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v WriteFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Input":
			return []string{}, true
		case "Path":
			return []string{}, true
		case "Permissions":
			return []string{}, true
		case "Contents":
			return []string{}, true
		case "Output":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}
